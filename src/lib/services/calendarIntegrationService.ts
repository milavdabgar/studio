import type { Timetable, TimetableEntry } from '@/types/entities';

interface CalendarEvent {
  id: string;
  title: string;
  description: string;
  startDate: Date;
  endDate: Date;
  location: string;
  attendees?: string[];
  recurrence?: {
    frequency: 'WEEKLY' | 'DAILY' | 'MONTHLY';
    interval: number;
    until?: Date;
    byDay?: string[];
  };
}

interface CalendarProvider {
  id: string;
  name: string;
  icon: string;
  color: string;
  isConnected: boolean;
  lastSync?: Date;
}

interface SyncResult {
  success: boolean;
  eventsCreated: number;
  eventsUpdated: number;
  eventsDeleted: number;
  errors: string[];
}

export class CalendarIntegrationService {
  private providers: Map<string, CalendarProvider> = new Map();
  private apiBaseUrl: string;

  constructor(apiBaseUrl: string = '/api/calendar') {
    this.apiBaseUrl = apiBaseUrl;
    this.initializeProviders();
  }

  private initializeProviders() {
    const defaultProviders: CalendarProvider[] = [
      {
        id: 'google',
        name: 'Google Calendar',
        icon: '📅',
        color: '#4285f4',
        isConnected: false
      },
      {
        id: 'outlook',
        name: 'Microsoft Outlook',
        icon: '📧',
        color: '#0078d4',
        isConnected: false
      },
      {
        id: 'apple',
        name: 'Apple Calendar',
        icon: '🍎',
        color: '#007aff',
        isConnected: false
      }
    ];

    defaultProviders.forEach(provider => {
      this.providers.set(provider.id, provider);
    });
  }

  // Convert timetable to calendar events
  private timetableToCalendarEvents(
    timetable: Timetable,
    semesterStartDate: Date,
    semesterEndDate: Date
  ): CalendarEvent[] {
    const events: CalendarEvent[] = [];
    const dayMapping = {
      'Monday': 1,
      'Tuesday': 2,
      'Wednesday': 3,
      'Thursday': 4,
      'Friday': 5,
      'Saturday': 6,
      'Sunday': 0
    };

    timetable.entries.forEach(entry => {
      const dayOfWeek = dayMapping[entry.dayOfWeek as keyof typeof dayMapping];
      
      // Find the first occurrence of this day in the semester
      let firstOccurrence = new Date(semesterStartDate);
      while (firstOccurrence.getDay() !== dayOfWeek) {
        firstOccurrence.setDate(firstOccurrence.getDate() + 1);
      }

      // Create start and end times
      const [startHour, startMinute] = entry.startTime.split(':').map(Number);
      const [endHour, endMinute] = entry.endTime.split(':').map(Number);

      const startDateTime = new Date(firstOccurrence);
      startDateTime.setHours(startHour, startMinute, 0, 0);

      const endDateTime = new Date(firstOccurrence);
      endDateTime.setHours(endHour, endMinute, 0, 0);

      events.push({
        id: `${timetable.id}-${entry.courseId}-${entry.dayOfWeek}-${entry.startTime}`,
        title: `${entry.courseId} - ${entry.entryType}`,
        description: this.generateEventDescription(entry, timetable),
        startDate: startDateTime,
        endDate: endDateTime,
        location: entry.roomId || 'TBD',
        recurrence: {
          frequency: 'WEEKLY',
          interval: 1,
          until: semesterEndDate,
          byDay: [entry.dayOfWeek.substring(0, 2).toUpperCase()]
        }
      });
    });

    return events;
  }

  private generateEventDescription(entry: TimetableEntry, timetable: Timetable): string {
    return [
      `Course: ${entry.courseId}`,
      `Type: ${entry.entryType}`,
      `Faculty: ${entry.facultyId}`,
      `Room: ${entry.roomId || 'TBD'}`,
      `Batch: ${timetable.batchId}`,
      `Academic Year: ${timetable.academicYear}`,
      `Semester: ${timetable.semester}`,
      '',
      'Generated by College Timetable System'
    ].join('\n');
  }

  // Google Calendar Integration
  async connectGoogleCalendar(userId: string): Promise<{ success: boolean; authUrl?: string; error?: string }> {
    try {
      const response = await fetch(`${this.apiBaseUrl}/google/connect`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userId })
      });

      const data = await response.json();
      
      if (data.success) {
        const provider = this.providers.get('google')!;
        provider.isConnected = true;
        provider.lastSync = new Date();
        this.providers.set('google', provider);
      }

      return data;
    } catch (error) {
      return { success: false, error: error instanceof Error ? error.message : 'Connection failed' };
    }
  }

  async syncToGoogleCalendar(
    userId: string,
    timetable: Timetable,
    calendarId: string = 'primary',
    semesterDates: { start: Date; end: Date }
  ): Promise<SyncResult> {
    try {
      const events = this.timetableToCalendarEvents(timetable, semesterDates.start, semesterDates.end);
      
      const response = await fetch(`${this.apiBaseUrl}/google/sync`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId,
          calendarId,
          events,
          timetableId: timetable.id
        })
      });

      const result = await response.json();
      
      if (result.success) {
        const provider = this.providers.get('google')!;
        provider.lastSync = new Date();
        this.providers.set('google', provider);
      }

      return result;
    } catch (error) {
      return {
        success: false,
        eventsCreated: 0,
        eventsUpdated: 0,
        eventsDeleted: 0,
        errors: [error instanceof Error ? error.message : 'Sync failed']
      };
    }
  }

  // Microsoft Outlook Integration
  async connectOutlookCalendar(userId: string): Promise<{ success: boolean; authUrl?: string; error?: string }> {
    try {
      const response = await fetch(`${this.apiBaseUrl}/outlook/connect`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userId })
      });

      const data = await response.json();
      
      if (data.success) {
        const provider = this.providers.get('outlook')!;
        provider.isConnected = true;
        provider.lastSync = new Date();
        this.providers.set('outlook', provider);
      }

      return data;
    } catch (error) {
      return { success: false, error: error instanceof Error ? error.message : 'Connection failed' };
    }
  }

  async syncToOutlookCalendar(
    userId: string,
    timetable: Timetable,
    semesterDates: { start: Date; end: Date }
  ): Promise<SyncResult> {
    try {
      const events = this.timetableToCalendarEvents(timetable, semesterDates.start, semesterDates.end);
      
      const response = await fetch(`${this.apiBaseUrl}/outlook/sync`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId,
          events,
          timetableId: timetable.id
        })
      });

      const result = await response.json();
      
      if (result.success) {
        const provider = this.providers.get('outlook')!;
        provider.lastSync = new Date();
        this.providers.set('outlook', provider);
      }

      return result;
    } catch (error) {
      return {
        success: false,
        eventsCreated: 0,
        eventsUpdated: 0,
        eventsDeleted: 0,
        errors: [error instanceof Error ? error.message : 'Sync failed']
      };
    }
  }

  // iCal Export (Universal Calendar Format)
  generateICalString(
    timetable: Timetable,
    semesterDates: { start: Date; end: Date },
    organizerEmail: string = 'noreply@college.edu'
  ): string {
    const events = this.timetableToCalendarEvents(timetable, semesterDates.start, semesterDates.end);
    
    let icalString = [
      'BEGIN:VCALENDAR',
      'VERSION:2.0',
      'PRODID:-//College Timetable System//Timetable Export//EN',
      'CALSCALE:GREGORIAN',
      'METHOD:PUBLISH',
      `X-WR-CALNAME:${timetable.name || `Timetable ${timetable.academicYear} Sem ${timetable.semester}`}`,
      'X-WR-CALDESC:Class schedule exported from College Timetable System',
      'X-WR-TIMEZONE:Asia/Kolkata'
    ].join('\r\n');

    events.forEach(event => {
      const startDateString = this.formatDateTimeForICal(event.startDate);
      const endDateString = this.formatDateTimeForICal(event.endDate);
      const createdDateString = this.formatDateTimeForICal(new Date());
      
      // Generate recurrence rule
      let rrule = '';
      if (event.recurrence) {
        rrule = `RRULE:FREQ=${event.recurrence.frequency};INTERVAL=${event.recurrence.interval}`;
        if (event.recurrence.until) {
          rrule += `;UNTIL=${this.formatDateForICal(event.recurrence.until)}T235959Z`;
        }
        if (event.recurrence.byDay?.length) {
          rrule += `;BYDAY=${event.recurrence.byDay.join(',')}`;
        }
      }

      icalString += '\r\n' + [
        'BEGIN:VEVENT',
        `UID:${event.id}@timetable.college.edu`,
        `DTSTART:${startDateString}`,
        `DTEND:${endDateString}`,
        `DTSTAMP:${createdDateString}`,
        `CREATED:${createdDateString}`,
        `LAST-MODIFIED:${createdDateString}`,
        `SUMMARY:${this.escapeICalString(event.title)}`,
        `DESCRIPTION:${this.escapeICalString(event.description)}`,
        `LOCATION:${this.escapeICalString(event.location)}`,
        `ORGANIZER:MAILTO:${organizerEmail}`,
        'STATUS:CONFIRMED',
        'TRANSP:OPAQUE',
        ...(rrule ? [rrule] : []),
        'BEGIN:VALARM',
        'TRIGGER:-PT15M',
        'ACTION:DISPLAY',
        'DESCRIPTION:Class starts in 15 minutes',
        'END:VALARM',
        'END:VEVENT'
      ].join('\r\n');
    });

    icalString += '\r\nEND:VCALENDAR';
    return icalString;
  }

  private formatDateTimeForICal(date: Date): string {
    return date.toISOString().replace(/[-:]/g, '').replace(/\.\d{3}/, '');
  }

  private formatDateForICal(date: Date): string {
    return date.toISOString().split('T')[0].replace(/-/g, '');
  }

  private escapeICalString(str: string): string {
    return str
      .replace(/\\/g, '\\\\')
      .replace(/;/g, '\\;')
      .replace(/,/g, '\\,')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '');
  }

  async exportToICalFile(
    timetable: Timetable,
    semesterDates: { start: Date; end: Date },
    filename?: string
  ): Promise<{ success: boolean; blob?: Blob; error?: string }> {
    try {
      const icalString = this.generateICalString(timetable, semesterDates);
      const blob = new Blob([icalString], { type: 'text/calendar;charset=utf-8' });
      
      // Trigger download
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename || `timetable-${timetable.id}.ics`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);

      return { success: true, blob };
    } catch (error) {
      return { success: false, error: error instanceof Error ? error.message : 'Export failed' };
    }
  }

  // Apple Calendar Integration (via iCal)
  async addToAppleCalendar(
    timetable: Timetable,
    semesterDates: { start: Date; end: Date }
  ): Promise<{ success: boolean; error?: string }> {
    try {
      const icalString = this.generateICalString(timetable, semesterDates);
      const blob = new Blob([icalString], { type: 'text/calendar' });
      const url = window.URL.createObjectURL(blob);
      
      // Create a temporary link to open with system calendar app
      const a = document.createElement('a');
      a.href = url;
      a.download = `timetable-${timetable.id}.ics`;
      a.click();
      
      window.URL.revokeObjectURL(url);
      
      const provider = this.providers.get('apple')!;
      provider.lastSync = new Date();
      this.providers.set('apple', provider);

      return { success: true };
    } catch (error) {
      return { success: false, error: error instanceof Error ? error.message : 'Export failed' };
    }
  }

  // Bulk sync to multiple providers
  async syncToMultipleProviders(
    userId: string,
    timetable: Timetable,
    providers: string[],
    semesterDates: { start: Date; end: Date }
  ): Promise<Map<string, SyncResult>> {
    const results = new Map<string, SyncResult>();
    
    const syncPromises = providers.map(async (providerId) => {
      let result: SyncResult;
      
      switch (providerId) {
        case 'google':
          result = await this.syncToGoogleCalendar(userId, timetable, 'primary', semesterDates);
          break;
        case 'outlook':
          result = await this.syncToOutlookCalendar(userId, timetable, semesterDates);
          break;
        case 'apple':
          const appleResult = await this.addToAppleCalendar(timetable, semesterDates);
          result = {
            success: appleResult.success,
            eventsCreated: appleResult.success ? timetable.entries.length : 0,
            eventsUpdated: 0,
            eventsDeleted: 0,
            errors: appleResult.error ? [appleResult.error] : []
          };
          break;
        default:
          result = {
            success: false,
            eventsCreated: 0,
            eventsUpdated: 0,
            eventsDeleted: 0,
            errors: [`Unknown provider: ${providerId}`]
          };
      }
      
      results.set(providerId, result);
    });

    await Promise.allSettled(syncPromises);
    return results;
  }

  // Provider management
  getConnectedProviders(): CalendarProvider[] {
    return Array.from(this.providers.values()).filter(p => p.isConnected);
  }

  getAllProviders(): CalendarProvider[] {
    return Array.from(this.providers.values());
  }

  async disconnectProvider(providerId: string, userId: string): Promise<boolean> {
    try {
      const response = await fetch(`${this.apiBaseUrl}/${providerId}/disconnect`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userId })
      });

      if (response.ok) {
        const provider = this.providers.get(providerId);
        if (provider) {
          provider.isConnected = false;
          provider.lastSync = undefined;
          this.providers.set(providerId, provider);
        }
        return true;
      }
      return false;
    } catch (error) {
      console.error(`Failed to disconnect ${providerId}:`, error);
      return false;
    }
  }

  // Sync status and management
  async getSyncStatus(userId: string): Promise<Map<string, { lastSync?: Date; nextSync?: Date; isActive: boolean }>> {
    const status = new Map();
    
    for (const [providerId, provider] of this.providers) {
      if (provider.isConnected) {
        status.set(providerId, {
          lastSync: provider.lastSync,
          nextSync: provider.lastSync ? new Date(provider.lastSync.getTime() + 24 * 60 * 60 * 1000) : undefined,
          isActive: true
        });
      } else {
        status.set(providerId, {
          isActive: false
        });
      }
    }
    
    return status;
  }

  // Calendar webhook handling for two-way sync
  async handleCalendarWebhook(
    providerId: string,
    webhookData: any
  ): Promise<{ success: boolean; actions: string[] }> {
    const actions: string[] = [];
    
    try {
      // Handle different types of calendar events
      switch (webhookData.type) {
        case 'event_created':
          actions.push('Created new event from external calendar');
          break;
        case 'event_updated':
          actions.push('Updated event from external calendar changes');
          break;
        case 'event_deleted':
          actions.push('Removed event deleted from external calendar');
          break;
        default:
          actions.push(`Handled ${webhookData.type} event`);
      }

      return { success: true, actions };
    } catch (error) {
      return { success: false, actions: [`Error processing webhook: ${error}`] };
    }
  }
}

// Global singleton instance
let calendarServiceInstance: CalendarIntegrationService | null = null;

export const getCalendarIntegrationService = (): CalendarIntegrationService => {
  if (!calendarServiceInstance) {
    calendarServiceInstance = new CalendarIntegrationService();
  }
  return calendarServiceInstance;
};

export default CalendarIntegrationService;