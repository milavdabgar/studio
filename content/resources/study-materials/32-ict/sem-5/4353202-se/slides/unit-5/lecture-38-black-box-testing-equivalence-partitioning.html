
<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Lecture 38: Black Box Testing - Equivalence Partitioning</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/theme/black.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/plugin/highlight/monokai.css">
</head>
<body>
    <div class="reveal">
        <div class="slides">
            <section>
                <h2>Lecture 38: Black Box Testing - Equivalence Partitioning</h2>
                <p>Unit 5: Software Coding and Testing (4353202)</p>
            </section>

            <section>
                <h3>Lecture Agenda</h3>
                <ul>
                    <li>Recap of Unit Testing</li>
                    <li>What is Black Box Testing?</li>
                    <li>Why Black Box Testing?</li>
                    <li>Introduction to Equivalence Partitioning</li>
                    <li>How Equivalence Partitioning Works</li>
                    <li>Example of Equivalence Partitioning</li>
                    <li>Advantages and Disadvantages</li>
                    <li>Key Takeaways</li>
                </ul>
            </section>

            <section>
                <h3>Recap of Unit Testing</h3>
                <p>Unit Testing is the first level of software testing, focusing on individual code components (units) to ensure they work as designed. It helps in early bug detection and improves code quality.</p>
            </section>

            <section>
                <h3>What is Black Box Testing?</h3>
                <p><strong>Black Box Testing</strong> is a software testing method in which the internal structure, design, implementation, and code of the item being tested are not known to the tester.</p>
                <p>It focuses solely on the inputs and outputs of the software, treating the system as a "black box."</p>
                <p>It is also known as **Functional Testing** because it verifies the functionality of the software against its requirements.</p>
            </section>

            <section>
                <h3>Why Black Box Testing?</h3>
                <ul>
                    <li><strong>User Perspective:</strong> Tests the system from the end-user's point of view.</li>
                    <li><strong>No Code Knowledge Required:</strong> Testers do not need programming knowledge.</li>
                    <li><strong>Early Testing:</strong> Can begin once requirements are finalized, even before code is written.</li>
                    <li><strong>Identifies Discrepancies:</strong> Effective in finding discrepancies between requirements and actual system behavior.</li>
                </ul>
            </section>

            <section>
                <h3>Introduction to Equivalence Partitioning</h3>
                <p><strong>Equivalence Partitioning</strong> is a black box testing technique that divides the input data into partitions (or classes) of equivalent data. Test cases are then designed to pick one representative value from each partition.</p>
                <p>The idea is that if one condition in a partition works, all conditions in that partition will work. Similarly, if one condition in a partition fails, all conditions in that partition will fail.</p>
            </section>

            <section>
                <h3>How Equivalence Partitioning Works</h3>
                <ol>
                    <li><strong>Identify Input Ranges:</strong> Determine the valid and invalid input ranges for a given field or condition.</li>
                    <li><strong>Divide into Partitions:</strong> Create partitions (equivalence classes) for both valid and invalid inputs.</li>
                    <li><strong>Select Test Cases:</strong> Choose one representative value from each partition as a test case.</li>
                </ol>
            </section>

            <section>
                <h3>Example: Age Input Field (18-60)</h3>
                <p>Consider a system that accepts age input between 18 and 60 (inclusive).</p>
                <ul>
                    <li><strong>Valid Partition:</strong> Ages from 18 to 60. (e.g., 35)</li>
                    <li><strong>Invalid Partition 1 (Below Min):</strong> Ages less than 18. (e.g., 10)</li>
                    <li><strong>Invalid Partition 2 (Above Max):</strong> Ages greater than 60. (e.g., 70)</li>
                </ul>
                <p><strong>Test Cases:</strong> 10, 35, 70</p>
                <div class="mermaid">
                    graph LR
                        subgraph Age Input (18-60)
                            A[<18] --> B(Invalid)
                            C[18-60] --> D(Valid)
                            E[>60] --> F(Invalid)
                        end
                </div>
            </section>

            <section>
                <h3>Advantages of Equivalence Partitioning</h3>
                <ul>
                    <li><strong>Reduces Test Cases:</strong> Significantly reduces the number of test cases needed, making testing more efficient.</li>
                    <li><strong>Effective:</strong> Helps in finding defects with a minimal set of test data.</li>
                    <li><strong>Systematic:</strong> Provides a systematic way to derive test cases.</li>
                    <li><strong>Covers Valid & Invalid Inputs:</strong> Ensures that both valid and invalid inputs are tested.</li>
                </ul>
            </section>

            <section>
                <h3>Disadvantages of Equivalence Partitioning</h3>
                <ul>
                    <li><strong>Doesn't Cover Boundary Values:</strong> It does not specifically test the boundary conditions, which are often prone to errors.</li>
                    <li><strong>Relies on Assumptions:</strong> Assumes that errors are uniformly distributed within a partition.</li>
                    <li><strong>Not Suitable for All Cases:</strong> May not be effective for complex conditions or non-numeric inputs.</li>
                </ul>
            </section>

            <section>
                <h3>Key Takeaways</h3>
                <ul>
                    <li>**Black Box Testing** focuses on inputs and outputs without knowing internal code.</li>
                    <li>**Equivalence Partitioning** divides input data into valid and invalid classes.</li>
                    <li>It helps **reduce the number of test cases** while ensuring good coverage.</li>
                    <li>It is a powerful technique but should be combined with other methods (like Boundary Value Analysis) for comprehensive testing.</li>
                </ul>
            </section>

            <section>
                <h3>Next Lecture</h3>
                <p>Topic: Black Box Testing - Boundary Value Analysis</p>
            </section>

            <section>
                <h2>Q & A</h2>
                <p>Questions & Discussion</p>
            </section>

        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/plugin/notes/notes.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/plugin/markdown/markdown.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/plugin/highlight/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/plugin/mermaid/mermaid.min.js"></script>
    <script>
        Reveal.initialize({
            hash: true,
            transition: 'slide',
            plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMermaid ]
        });
    </script>
</body>
</html>
