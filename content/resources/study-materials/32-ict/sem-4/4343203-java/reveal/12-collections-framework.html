<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Java Programming - Collections Framework</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/reveal.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/theme/white.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/plugin/highlight/monokai.css">
    <style>
        .reveal h1, .reveal h2, .reveal h3 { color: #2c3e50; }
        .reveal .slides section { text-align: left; padding: 10px 30px; height: 90vh; box-sizing: border-box; overflow: hidden; }
        .reveal .title-slide { text-align: center; }
        .reveal .center { text-align: center; }
        .reveal pre code { font-size: 0.7em; line-height: 1.1; max-height: 300px; overflow-y: auto; }
        .reveal h2 { font-size: 1.6em; margin-bottom: 0.4em; }
        .reveal h3 { font-size: 1.3em; margin-bottom: 0.3em; }
        .reveal h4 { font-size: 1.0em; margin-bottom: 0.2em; }
        .reveal ul, .reveal ol { font-size: 0.85em; margin: 0.4em 0; }
        .reveal li { margin: 0.2em 0; }
        .highlight { background-color: #fff3cd; padding: 6px; border-left: 4px solid #ffc107; margin: 6px 0; font-size: 0.85em; }
        .concept-box { background-color: #e8f4f8; padding: 8px; border-radius: 5px; margin: 6px 0; font-size: 0.8em; }
        .two-column { display: flex; gap: 15px; font-size: 0.8em; }
        .three-column { display: flex; gap: 10px; font-size: 0.75em; }
        .column { flex: 1; }
        .compact-list li { margin: 0.1em 0; font-size: 0.8em; }
        .small-text { font-size: 0.75em; }
        .table-style { font-size: 0.7em; width: 100%; border-collapse: collapse; }
        .table-style th, .table-style td { border: 1px solid #ddd; padding: 4px; text-align: center; }
        .table-style th { background-color: #f2f2f2; font-weight: bold; }
        .collection-box { background: #e8f5e8; padding: 8px; border-radius: 5px; margin: 6px 0; font-size: 0.8em; border-left: 4px solid #4caf50; }
        .list-box { background: #e3f2fd; padding: 8px; border-radius: 5px; margin: 6px 0; font-size: 0.8em; border-left: 4px solid #2196f3; }
        .set-box { background: #fff3e0; padding: 8px; border-radius: 5px; margin: 6px 0; font-size: 0.8em; border-left: 4px solid #ff9800; }
        .map-box { background: #f3e5f5; padding: 8px; border-radius: 5px; margin: 6px 0; font-size: 0.8em; border-left: 4px solid #9c27b0; }
    </style>
</head>
<body>
    <div class="reveal">
        <div class="slides">
            <!-- Title Slide -->
            <section class="title-slide">
                <h1>Java Programming Language</h1>
                <h2>Chapter 12: Collections Framework</h2>
                <p>Data Structures and Algorithms</p>
                <br>
                <p><small>Course: 4343203 - Java Programming</small></p>
            </section>

            <!-- Table of Contents -->
            <section>
                <h2>What We'll Cover</h2>
                <ul class="compact-list">
                    <li>Collections Framework Overview</li>
                    <li>List Interface and Implementations</li>
                    <li>Set Interface and Implementations</li>
                    <li>Map Interface and Implementations</li>
                    <li>Queue and Deque Interfaces</li>
                    <li>Iterators and Enhanced For Loop</li>
                    <li>Collections Utility Class</li>
                    <li>Generics in Collections</li>
                </ul>
            </section>

            <!-- Collections Hierarchy -->
            <section>
                <h2>Collections Framework Hierarchy</h2>
                <div class="center">
                    <img src="diagrams/collections-hierarchy.svg" alt="Java Collections Hierarchy" style="width: 95%; max-height: 75vh;">
                </div>
            </section>

            <!-- Collections Overview -->
            <section>
                <section>
                    <h2>Collections Framework Overview</h2>
                    <div class="highlight">
                        <p><strong>Collections Framework</strong> provides a unified architecture for storing and manipulating groups of objects</p>
                    </div>
                </section>

                <section>
                    <h3>Core Interfaces</h3>
                    <div class="concept-box">
                        <h4>Main Collection Interfaces:</h4>
                        <ul class="compact-list">
                            <li><strong>Collection:</strong> Root interface for most collections</li>
                            <li><strong>List:</strong> Ordered collection (allows duplicates)</li>
                            <li><strong>Set:</strong> Collection with no duplicates</li>
                            <li><strong>Queue:</strong> Collection for holding elements before processing</li>
                            <li><strong>Map:</strong> Key-value pairs (not part of Collection hierarchy)</li>
                        </ul>
                    </div>
                    <div class="two-column">
                        <div class="column">
                            <h4>Benefits of Collections:</h4>
                            <div class="collection-box">
                                <ul class="compact-list">
                                    <li>Reduces programming effort</li>
                                    <li>Increases performance</li>
                                    <li>Provides interoperability</li>
                                    <li>Reduces learning effort</li>
                                    <li>Promotes software reuse</li>
                                </ul>
                            </div>
                        </div>
                        <div class="column">
                            <h4>Collection vs Collections:</h4>
                            <div class="collection-box">
                                <ul class="compact-list">
                                    <li><strong>Collection:</strong> Interface representing a group of objects</li>
                                    <li><strong>Collections:</strong> Utility class with static methods</li>
                                    <li><strong>Collection methods:</strong> add(), remove(), size(), etc.</li>
                                    <li><strong>Collections methods:</strong> sort(), reverse(), max(), etc.</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>Basic Collection Operations</h3>
                    <pre><code data-trim>
import java.util.*;

public class CollectionBasics {
    public static void main(String[] args) {
        // Creating different types of collections
        List<String> list = new ArrayList<>();
        Set<String> set = new HashSet<>();
        Map<String, Integer> map = new HashMap<>();
        
        // Basic operations on List
        list.add("Apple");
        list.add("Banana");
        list.add("Cherry");
        list.add("Apple"); // Duplicates allowed
        
        System.out.println("List: " + list);
        System.out.println("List size: " + list.size());
        System.out.println("Contains Apple: " + list.contains("Apple"));
        
        // Basic operations on Set
        set.add("Apple");
        set.add("Banana");
        set.add("Cherry");
        set.add("Apple"); // Duplicate ignored
        
        System.out.println("Set: " + set);
        System.out.println("Set size: " + set.size());
        
        // Basic operations on Map
        map.put("Apple", 5);
        map.put("Banana", 3);
        map.put("Cherry", 8);
        
        System.out.println("Map: " + map);
        System.out.println("Apple count: " + map.get("Apple"));
        
        // Common operations
        System.out.println("List is empty: " + list.isEmpty());
        System.out.println("Set contains Banana: " + set.contains("Banana"));
        System.out.println("Map keys: " + map.keySet());
        System.out.println("Map values: " + map.values());
    }
}
                    </code></pre>
                </section>
            </section>

            <!-- List Interface -->
            <section>
                <section>
                    <h2>List Interface</h2>
                    <div class="highlight">
                        <p><strong>List</strong> is an ordered collection that allows duplicates and indexed access</p>
                    </div>
                </section>

                <section>
                    <h3>List Implementations</h3>
                    <div class="three-column">
                        <div class="column">
                            <div class="list-box">
                                <h4>ArrayList</h4>
                                <ul class="compact-list">
                                    <li>Resizable array implementation</li>
                                    <li>Fast random access (O(1))</li>
                                    <li>Slow insertion/deletion (O(n))</li>
                                    <li>Not synchronized</li>
                                    <li>Good for frequent access</li>
                                </ul>
                            </div>
                        </div>
                        <div class="column">
                            <div class="list-box">
                                <h4>LinkedList</h4>
                                <ul class="compact-list">
                                    <li>Doubly-linked list implementation</li>
                                    <li>Slow random access (O(n))</li>
                                    <li>Fast insertion/deletion (O(1))</li>
                                    <li>Implements List and Deque</li>
                                    <li>Good for frequent modifications</li>
                                </ul>
                            </div>
                        </div>
                        <div class="column">
                            <div class="list-box">
                                <h4>Vector</h4>
                                <ul class="compact-list">
                                    <li>Synchronized version of ArrayList</li>
                                    <li>Thread-safe but slower</li>
                                    <li>Legacy class (avoid in new code)</li>
                                    <li>Use Collections.synchronizedList()</li>
                                    <li>Or use CopyOnWriteArrayList</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>ArrayList Examples</h3>
                    <div class="two-column">
                        <div class="column">
                            <h4>Basic ArrayList Operations:</h4>
                            <pre><code data-trim>
import java.util.*;

public class ArrayListExample {
    public static void main(String[] args) {
        ArrayList<Integer> numbers = new ArrayList<>();
        
        // Adding elements
        numbers.add(10);
        numbers.add(20);
        numbers.add(30);
        numbers.add(1, 15); // Insert at index 1
        
        System.out.println("ArrayList: " + numbers);
        
        // Accessing elements
        System.out.println("Element at index 2: " + numbers.get(2));
        System.out.println("First element: " + numbers.get(0));
        System.out.println("Last element: " + numbers.get(numbers.size() - 1));
        
        // Modifying elements
        numbers.set(0, 5); // Replace element at index 0
        System.out.println("After modification: " + numbers);
        
        // Searching
        System.out.println("Index of 20: " + numbers.indexOf(20));
        System.out.println("Contains 30: " + numbers.contains(30));
        
        // Removing elements
        numbers.remove(2); // Remove by index
        numbers.remove(Integer.valueOf(20)); // Remove by value
        System.out.println("After removal: " + numbers);
        
        // Size and capacity
        System.out.println("Size: " + numbers.size());
        numbers.trimToSize(); // Trim capacity to current size
    }
}
                            </code></pre>
                        </div>
                        <div class="column">
                            <h4>ArrayList vs LinkedList Performance:</h4>
                            <pre><code data-trim>
public class ListPerformanceComparison {
    public static void main(String[] args) {
        final int SIZE = 100000;
        
        // ArrayList performance test
        ArrayList<Integer> arrayList = new ArrayList<>();
        long startTime = System.currentTimeMillis();
        
        // Add elements to end
        for (int i = 0; i < SIZE; i++) {
            arrayList.add(i);
        }
        long arrayListAddTime = System.currentTimeMillis() - startTime;
        
        // Access elements randomly
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 1000; i++) {
            int index = (int) (Math.random() * SIZE);
            arrayList.get(index);
        }
        long arrayListAccessTime = System.currentTimeMillis() - startTime;
        
        // LinkedList performance test
        LinkedList<Integer> linkedList = new LinkedList<>();
        startTime = System.currentTimeMillis();
        
        // Add elements to end
        for (int i = 0; i < SIZE; i++) {
            linkedList.add(i);
        }
        long linkedListAddTime = System.currentTimeMillis() - startTime;
        
        // Access elements randomly
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 1000; i++) {
            int index = (int) (Math.random() * SIZE);
            linkedList.get(index);
        }
        long linkedListAccessTime = System.currentTimeMillis() - startTime;
        
        System.out.println("ArrayList add time: " + arrayListAddTime + "ms");
        System.out.println("LinkedList add time: " + linkedListAddTime + "ms");
        System.out.println("ArrayList access time: " + arrayListAccessTime + "ms");
        System.out.println("LinkedList access time: " + linkedListAccessTime + "ms");
    }
}
                            </code></pre>
                        </div>
                    </div>
                </section>
            </section>

            <!-- Set Interface -->
            <section>
                <section>
                    <h2>Set Interface</h2>
                    <div class="highlight">
                        <p><strong>Set</strong> is a collection that contains no duplicate elements</p>
                    </div>
                </section>

                <section>
                    <h3>Set Implementations</h3>
                    <div class="three-column">
                        <div class="column">
                            <div class="set-box">
                                <h4>HashSet</h4>
                                <ul class="compact-list">
                                    <li>Hash table implementation</li>
                                    <li>No ordering guarantee</li>
                                    <li>O(1) add, remove, contains</li>
                                    <li>Allows one null element</li>
                                    <li>Not synchronized</li>
                                </ul>
                            </div>
                        </div>
                        <div class="column">
                            <div class="set-box">
                                <h4>LinkedHashSet</h4>
                                <ul class="compact-list">
                                    <li>Hash table + linked list</li>
                                    <li>Maintains insertion order</li>
                                    <li>Slightly slower than HashSet</li>
                                    <li>Predictable iteration order</li>
                                    <li>Good for ordered unique elements</li>
                                </ul>
                            </div>
                        </div>
                        <div class="column">
                            <div class="set-box">
                                <h4>TreeSet</h4>
                                <ul class="compact-list">
                                    <li>Red-Black tree implementation</li>
                                    <li>Sorted order (natural or custom)</li>
                                    <li>O(log n) add, remove, contains</li>
                                    <li>No null elements allowed</li>
                                    <li>Implements NavigableSet</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>Set Examples</h3>
                    <div class="two-column">
                        <div class="column">
                            <h4>HashSet Operations:</h4>
                            <pre><code data-trim>
import java.util.*;

public class SetExample {
    public static void main(String[] args) {
        // HashSet - no ordering
        Set<String> fruits = new HashSet<>();
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Cherry");
        fruits.add("Apple"); // Duplicate ignored
        
        System.out.println("HashSet: " + fruits);
        
        // LinkedHashSet - maintains insertion order
        Set<String> orderedFruits = new LinkedHashSet<>();
        orderedFruits.add("Apple");
        orderedFruits.add("Banana");
        orderedFruits.add("Cherry");
        orderedFruits.add("Apple"); // Duplicate ignored
        
        System.out.println("LinkedHashSet: " + orderedFruits);
        
        // TreeSet - sorted order
        Set<String> sortedFruits = new TreeSet<>();
        sortedFruits.add("Banana");
        sortedFruits.add("Apple");
        sortedFruits.add("Cherry");
        
        System.out.println("TreeSet: " + sortedFruits);
        
        // Set operations
        Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));
        Set<Integer> set2 = new HashSet<>(Arrays.asList(4, 5, 6, 7, 8));
        
        // Union
        Set<Integer> union = new HashSet<>(set1);
        union.addAll(set2);
        System.out.println("Union: " + union);
        
        // Intersection
        Set<Integer> intersection = new HashSet<>(set1);
        intersection.retainAll(set2);
        System.out.println("Intersection: " + intersection);
        
        // Difference
        Set<Integer> difference = new HashSet<>(set1);
        difference.removeAll(set2);
        System.out.println("Difference: " + difference);
    }
}
                            </code></pre>
                        </div>
                        <div class="column">
                            <h4>TreeSet with Custom Ordering:</h4>
                            <pre><code data-trim>
public class TreeSetExample {
    static class Student implements Comparable<Student> {
        String name;
        int age;
        double grade;
        
        public Student(String name, int age, double grade) {
            this.name = name;
            this.age = age;
            this.grade = grade;
        }
        
        @Override
        public int compareTo(Student other) {
            // Sort by grade (descending), then by name
            int gradeComparison = Double.compare(other.grade, this.grade);
            if (gradeComparison != 0) {
                return gradeComparison;
            }
            return this.name.compareTo(other.name);
        }
        
        @Override
        public String toString() {
            return name + "(" + grade + ")";
        }
    }
    
    public static void main(String[] args) {
        TreeSet<Student> students = new TreeSet<>();
        students.add(new Student("Alice", 20, 85.5));
        students.add(new Student("Bob", 19, 92.0));
        students.add(new Student("Charlie", 21, 78.5));
        students.add(new Student("Diana", 20, 92.0));
        
        System.out.println("Students sorted by grade:");
        for (Student student : students) {
            System.out.println(student);
        }
        
        // TreeSet with custom comparator
        TreeSet<String> lengthSorted = new TreeSet<>((s1, s2) -> {
            int lengthComparison = Integer.compare(s1.length(), s2.length());
            return lengthComparison != 0 ? lengthComparison : s1.compareTo(s2);
        });
        
        lengthSorted.addAll(Arrays.asList("Java", "Python", "C", "JavaScript", "Go"));
        System.out.println("Strings sorted by length: " + lengthSorted);
    }
}
                            </code></pre>
                        </div>
                    </div>
                </section>
            </section>

            <!-- Map Interface -->
            <section>
                <section>
                    <h2>Map Interface</h2>
                    <div class="highlight">
                        <p><strong>Map</strong> stores key-value pairs with unique keys</p>
                    </div>
                </section>

                <section>
                    <h3>Map Implementations</h3>
                    <div class="three-column">
                        <div class="column">
                            <div class="map-box">
                                <h4>HashMap</h4>
                                <ul class="compact-list">
                                    <li>Hash table implementation</li>
                                    <li>No ordering guarantee</li>
                                    <li>O(1) get, put, remove</li>
                                    <li>Allows one null key</li>
                                    <li>Not synchronized</li>
                                </ul>
                            </div>
                        </div>
                        <div class="column">
                            <div class="map-box">
                                <h4>LinkedHashMap</h4>
                                <ul class="compact-list">
                                    <li>Hash table + linked list</li>
                                    <li>Maintains insertion order</li>
                                    <li>Can maintain access order</li>
                                    <li>Useful for LRU caches</li>
                                    <li>Slightly slower than HashMap</li>
                                </ul>
                            </div>
                        </div>
                        <div class="column">
                            <div class="map-box">
                                <h4>TreeMap</h4>
                                <ul class="compact-list">
                                    <li>Red-Black tree implementation</li>
                                    <li>Sorted by key (natural or custom)</li>
                                    <li>O(log n) get, put, remove</li>
                                    <li>No null keys allowed</li>
                                    <li>Implements NavigableMap</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </section>

                <section>
                    <h3>Map Examples</h3>
                    <div class="two-column">
                        <div class="column">
                            <h4>HashMap Operations:</h4>
                            <pre><code data-trim>
import java.util.*;

public class MapExample {
    public static void main(String[] args) {
        Map<String, Integer> studentGrades = new HashMap<>();
        
        // Adding key-value pairs
        studentGrades.put("Alice", 85);
        studentGrades.put("Bob", 92);
        studentGrades.put("Charlie", 78);
        studentGrades.put("Diana", 96);
        
        System.out.println("Student grades: " + studentGrades);
        
        // Accessing values
        System.out.println("Alice's grade: " + studentGrades.get("Alice"));
        System.out.println("Eve's grade: " + studentGrades.get("Eve")); // null
        System.out.println("Eve's grade (default): " + 
            studentGrades.getOrDefault("Eve", 0));
        
        // Checking existence
        System.out.println("Contains Alice: " + studentGrades.containsKey("Alice"));
        System.out.println("Contains grade 92: " + studentGrades.containsValue(92));
        
        // Updating values
        studentGrades.put("Alice", 88); // Overwrites existing value
        studentGrades.putIfAbsent("Eve", 82); // Only if key doesn't exist
        
        // Advanced operations (Java 8+)
        studentGrades.merge("Alice", 5, Integer::sum); // Alice: 88 + 5 = 93
        studentGrades.compute("Bob", (key, value) -> value * 2); // Bob: 92 * 2 = 184
        studentGrades.computeIfAbsent("Frank", key -> key.length() * 10);
        
        System.out.println("After updates: " + studentGrades);
        
        // Iterating over map
        System.out.println("\nIterating over entries:");
        for (Map.Entry<String, Integer> entry : studentGrades.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        
        System.out.println("\nUsing forEach (Java 8+):");
        studentGrades.forEach((name, grade) -> 
            System.out.println(name + " scored " + grade));
    }
}
                            </code></pre>
                        </div>
                        <div class="column">
                            <h4>TreeMap and Word Frequency:</h4>
                            <pre><code data-trim>
public class WordFrequency {
    public static void main(String[] args) {
        String text = "the quick brown fox jumps over the lazy dog the fox is quick";
        
        // Count word frequencies using TreeMap (sorted by key)
        Map<String, Integer> wordCount = new TreeMap<>();
        
        String[] words = text.toLowerCase().split("\\s+");
        
        for (String word : words) {
            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);
        }
        
        System.out.println("Word frequencies (alphabetically sorted):");
        wordCount.forEach((word, count) -> 
            System.out.println(word + ": " + count));
        
        // Find most frequent word
        String mostFrequentWord = wordCount.entrySet().stream()
            .max(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
            .orElse("No words");
        
        System.out.println("\nMost frequent word: " + mostFrequentWord);
        
        // Group by frequency
        Map<Integer, List<String>> frequencyGroups = new TreeMap<>();
        for (Map.Entry<String, Integer> entry : wordCount.entrySet()) {
            frequencyGroups.computeIfAbsent(entry.getValue(), 
                k -> new ArrayList<>()).add(entry.getKey());
        }
        
        System.out.println("\nWords grouped by frequency:");
        frequencyGroups.forEach((freq, words) -> 
            System.out.println("Frequency " + freq + ": " + words));
    }
}
                            </code></pre>
                        </div>
                    </div>
                </section>
            </section>

            <!-- Queue and Deque -->
            <section>
                <section>
                    <h2>Queue and Deque Interfaces</h2>
                    <div class="highlight">
                        <p><strong>Queue</strong> and <strong>Deque</strong> provide FIFO and double-ended queue operations</p>
                    </div>
                </section>

                <section>
                    <h3>Queue Implementations</h3>
                    <div class="two-column">
                        <div class="column">
                            <div class="collection-box">
                                <h4>Common Queue Implementations:</h4>
                                <ul class="compact-list">
                                    <li><strong>LinkedList:</strong> Implements Queue and Deque</li>
                                    <li><strong>ArrayDeque:</strong> Resizable array deque</li>
                                    <li><strong>PriorityQueue:</strong> Heap-based priority queue</li>
                                    <li><strong>BlockingQueue:</strong> Thread-safe queues</li>
                                </ul>
                            </div>
                            <h4>Queue Example:</h4>
                            <pre><code data-trim>
import java.util.*;

public class QueueExample {
    public static void main(String[] args) {
        Queue<String> queue = new LinkedList<>();
        
        // Adding elements
        queue.offer("First");
        queue.offer("Second");
        queue.offer("Third");
        
        System.out.println("Queue: " + queue);
        
        // Accessing head element
        System.out.println("Head (peek): " + queue.peek());
        System.out.println("Head (element): " + queue.element());
        
        // Removing elements
        String removed = queue.poll(); // Removes and returns head
        System.out.println("Removed: " + removed);
        System.out.println("Queue after poll: " + queue);
        
        // Queue methods comparison
        // offer() vs add() - same for most implementations
        // poll() vs remove() - poll returns null if empty, remove throws exception
        // peek() vs element() - peek returns null if empty, element throws exception
    }
}
                            </code></pre>
                        </div>
                        <div class="column">
                            <h4>PriorityQueue Example:</h4>
                            <pre><code data-trim>
public class PriorityQueueExample {
    static class Task implements Comparable<Task> {
        String name;
        int priority;
        
        public Task(String name, int priority) {
            this.name = name;
            this.priority = priority;
        }
        
        @Override
        public int compareTo(Task other) {
            return Integer.compare(other.priority, this.priority); // Higher priority first
        }
        
        @Override
        public String toString() {
            return name + "(priority:" + priority + ")";
        }
    }
    
    public static void main(String[] args) {
        PriorityQueue<Task> taskQueue = new PriorityQueue<>();
        
        taskQueue.offer(new Task("Low priority task", 1));
        taskQueue.offer(new Task("High priority task", 5));
        taskQueue.offer(new Task("Medium priority task", 3));
        taskQueue.offer(new Task("Critical task", 10));
        
        System.out.println("Processing tasks by priority:");
        while (!taskQueue.isEmpty()) {
            Task task = taskQueue.poll();
            System.out.println("Processing: " + task);
        }
        
        // Using PriorityQueue with numbers
        PriorityQueue<Integer> numbers = new PriorityQueue<>();
        numbers.addAll(Arrays.asList(5, 2, 8, 1, 9, 3));
        
        System.out.println("\nNumbers in priority order (min-heap):");
        while (!numbers.isEmpty()) {
            System.out.print(numbers.poll() + " ");
        }
    }
}
                            </code></pre>
                        </div>
                    </div>
                </section>
            </section>

            <!-- Iterators -->
            <section>
                <section>
                    <h2>Iterators and Enhanced For Loop</h2>
                    <div class="highlight">
                        <p><strong>Iterators</strong> provide a standard way to traverse collections</p>
                    </div>
                </section>

                <section>
                    <h3>Iterator Types and Usage</h3>
                    <div class="two-column">
                        <div class="column">
                            <h4>Iterator Examples:</h4>
                            <pre><code data-trim>
import java.util.*;

public class IteratorExample {
    public static void main(String[] args) {
        List<String> fruits = Arrays.asList("Apple", "Banana", "Cherry", "Date");
        
        // Enhanced for loop (for-each)
        System.out.println("Enhanced for loop:");
        for (String fruit : fruits) {
            System.out.println(fruit);
        }
        
        // Iterator
        System.out.println("\nUsing Iterator:");
        Iterator<String> iterator = fruits.iterator();
        while (iterator.hasNext()) {
            String fruit = iterator.next();
            System.out.println(fruit);
        }
        
        // ListIterator (bidirectional)
        List<String> mutableFruits = new ArrayList<>(fruits);
        System.out.println("\nUsing ListIterator:");
        ListIterator<String> listIterator = mutableFruits.listIterator();
        
        // Forward iteration
        while (listIterator.hasNext()) {
            String fruit = listIterator.next();
            if (fruit.equals("Banana")) {
                listIterator.set("Blueberry"); // Modify during iteration
            }
        }
        
        // Backward iteration
        System.out.println("Backward iteration:");
        while (listIterator.hasPrevious()) {
            System.out.println(listIterator.previous());
        }
        
        System.out.println("Modified list: " + mutableFruits);
    }
}
                            </code></pre>
                        </div>
                        <div class="column">
                            <h4>Safe Removal During Iteration:</h4>
                            <pre><code data-trim>
public class SafeIterationExample {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>(
            Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
        
        // ❌ WRONG - ConcurrentModificationException
        /*
        for (Integer number : numbers) {
            if (number % 2 == 0) {
                numbers.remove(number); // Throws exception!
            }
        }
        */
        
        // ✅ CORRECT - Using Iterator
        Iterator<Integer> iterator = numbers.iterator();
        while (iterator.hasNext()) {
            Integer number = iterator.next();
            if (number % 2 == 0) {
                iterator.remove(); // Safe removal
            }
        }
        System.out.println("After removing even numbers: " + numbers);
        
        // ✅ CORRECT - Using removeIf (Java 8+)
        List<Integer> numbers2 = new ArrayList<>(
            Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
        numbers2.removeIf(number -> number % 2 == 0);
        System.out.println("Using removeIf: " + numbers2);
        
        // ✅ CORRECT - Using streams (Java 8+)
        List<Integer> numbers3 = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        List<Integer> oddNumbers = numbers3.stream()
            .filter(number -> number % 2 != 0)
            .collect(Collectors.toList());
        System.out.println("Using streams: " + oddNumbers);
    }
}
                            </code></pre>
                        </div>
                    </div>
                </section>
            </section>

            <!-- Collections Utility -->
            <section>
                <section>
                    <h2>Collections Utility Class</h2>
                    <div class="highlight">
                        <p><strong>Collections</strong> class provides static utility methods for collections</p>
                    </div>
                </section>

                <section>
                    <h3>Common Collections Methods</h3>
                    <pre><code data-trim>
import java.util.*;

public class CollectionsUtilityExample {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>(Arrays.asList(5, 2, 8, 1, 9, 3));
        System.out.println("Original list: " + numbers);
        
        // Sorting
        Collections.sort(numbers);
        System.out.println("Sorted: " + numbers);
        
        Collections.sort(numbers, Collections.reverseOrder());
        System.out.println("Reverse sorted: " + numbers);
        
        // Shuffling
        Collections.shuffle(numbers);
        System.out.println("Shuffled: " + numbers);
        
        // Searching (requires sorted list)
        Collections.sort(numbers);
        int index = Collections.binarySearch(numbers, 5);
        System.out.println("Index of 5: " + index);
        
        // Min and Max
        System.out.println("Min: " + Collections.min(numbers));
        System.out.println("Max: " + Collections.max(numbers));
        
        // Frequency
        List<String> words = Arrays.asList("apple", "banana", "apple", "cherry", "apple");
        System.out.println("Frequency of 'apple': " + Collections.frequency(words, "apple"));
        
        // Reversing
        Collections.reverse(numbers);
        System.out.println("Reversed: " + numbers);
        
        // Rotating
        Collections.rotate(numbers, 2);
        System.out.println("Rotated by 2: " + numbers);
        
        // Filling
        List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c", "d"));
        Collections.fill(list, "x");
        System.out.println("Filled with 'x': " + list);
        
        // Creating immutable collections
        List<String> immutableList = Collections.unmodifiableList(
            Arrays.asList("read", "only", "list"));
        System.out.println("Immutable list: " + immutableList);
        
        // Synchronized collections
        List<String> syncList = Collections.synchronizedList(new ArrayList<>());
        Set<String> syncSet = Collections.synchronizedSet(new HashSet<>());
        Map<String, String> syncMap = Collections.synchronizedMap(new HashMap<>());
        
        // Empty collections
        List<String> emptyList = Collections.emptyList();
        Set<String> emptySet = Collections.emptySet();
        Map<String, String> emptyMap = Collections.emptyMap();
        
        // Singleton collections
        List<String> singletonList = Collections.singletonList("only-item");
        Set<String> singletonSet = Collections.singleton("only-item");
    }
}
                    </code></pre>
                </section>
            </section>

            <!-- Generics in Collections -->
            <section>
                <section>
                    <h2>Generics in Collections</h2>
                    <div class="highlight">
                        <p><strong>Generics</strong> provide type safety and eliminate the need for casting</p>
                    </div>
                </section>

                <section>
                    <h3>Generic Collections</h3>
                    <div class="two-column">
                        <div class="column">
                            <h4>Without Generics (Pre-Java 5):</h4>
                            <pre><code data-trim>
// ❌ Old way - no type safety
List list = new ArrayList();
list.add("String");
list.add(Integer.valueOf(42));
list.add(new Date());

// Requires casting and can fail at runtime
String str = (String) list.get(0); // OK
String str2 = (String) list.get(1); // ClassCastException!
                            </code></pre>
                            
                            <h4>With Generics (Java 5+):</h4>
                            <pre><code data-trim>
// ✅ New way - type safety
List<String> stringList = new ArrayList<String>();
stringList.add("String");
// stringList.add(42); // Compile-time error!

String str = stringList.get(0); // No casting needed

// Diamond operator (Java 7+)
List<String> strings = new ArrayList<>();
Map<String, Integer> map = new HashMap<>();
                            </code></pre>
                        </div>
                        <div class="column">
                            <h4>Complex Generic Examples:</h4>
                            <pre><code data-trim>
public class GenericCollectionsExample {
    public static void main(String[] args) {
        // List of Lists
        List<List<String>> matrix = new ArrayList<>();
        matrix.add(Arrays.asList("A", "B", "C"));
        matrix.add(Arrays.asList("D", "E", "F"));
        
        // Map with complex values
        Map<String, List<Integer>> studentGrades = new HashMap<>();
        studentGrades.put("Alice", Arrays.asList(85, 92, 78));
        studentGrades.put("Bob", Arrays.asList(90, 87, 95));
        
        // Set of Maps
        Set<Map<String, Object>> records = new HashSet<>();
        Map<String, Object> record1 = new HashMap<>();
        record1.put("name", "John");
        record1.put("age", 25);
        records.add(record1);
        
        // Wildcards
        List<? extends Number> numbers = new ArrayList<Integer>();
        List<? super Integer> integers = new ArrayList<Number>();
        
        // Bounded type parameters
        Map<String, ? extends Collection<String>> collections = new HashMap<>();
        collections.put("list", Arrays.asList("a", "b", "c"));
        collections.put("set", new HashSet<>(Arrays.asList("x", "y", "z")));
        
        System.out.println("Matrix: " + matrix);
        System.out.println("Student grades: " + studentGrades);
        System.out.println("Collections map: " + collections);
    }
}
                            </code></pre>
                        </div>
                    </div>
                </section>
            </section>

            <!-- Summary -->
            <section>
                <h2>Chapter Summary</h2>
                <div class="two-column">
                    <div class="column">
                        <h3>Collections Framework:</h3>
                        <ul class="compact-list">
                            <li>List: ArrayList, LinkedList, Vector</li>
                            <li>Set: HashSet, LinkedHashSet, TreeSet</li>
                            <li>Map: HashMap, LinkedHashMap, TreeMap</li>
                            <li>Queue: LinkedList, ArrayDeque, PriorityQueue</li>
                            <li>Collections utility class methods</li>
                        </ul>
                    </div>
                    <div class="column">
                        <h3>Practical Skills:</h3>
                        <ul class="compact-list">
                            <li>Choosing appropriate collection types</li>
                            <li>Using iterators safely</li>
                            <li>Understanding performance characteristics</li>
                            <li>Working with generics effectively</li>
                            <li>Applying collections in real-world scenarios</li>
                        </ul>
                    </div>
                </div>
                <div class="highlight center">
                    <p><strong>Next:</strong> Programming Examples and Applications</p>
                </div>
            </section>

            <!-- Thank You -->
            <section class="title-slide">
                <h1>Thank You!</h1>
                <h2>Questions?</h2>
                <br>
                <p>Ready to explore Programming Examples!</p>
            </section>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/reveal.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/plugin/notes/notes.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/plugin/markdown/markdown.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/plugin/highlight/highlight.js"></script>
    <script>
        Reveal.initialize({
            hash: true,
            transition: 'slide',
            transitionSpeed: 'default',
            backgroundTransition: 'fade',
            plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
        });
    </script>
</body>
</html>