<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java Advanced Topics - Wrapper Classes & Command Line Arguments</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/theme/white.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/plugin/highlight/monokai.css">
    <style>
        .reveal .slides {
            text-align: left;
            font-size: 0.75em;
            height: 90vh;
            overflow: hidden;
        }
        .reveal h1, .reveal h2, .reveal h3 {
            text-align: center;
            margin-bottom: 20px;
        }
        .reveal h1 { font-size: 2em; }
        .reveal h2 { font-size: 1.5em; }
        .reveal h3 { font-size: 1.2em; }
        .reveal pre {
            font-size: 0.7em;
            line-height: 1.2;
            margin: 10px 0;
        }
        .reveal code {
            font-size: 0.85em;
        }
        .reveal .two-column {
            display: flex;
            gap: 20px;
        }
        .reveal .column {
            flex: 1;
        }
        .reveal ul, .reveal ol {
            font-size: 0.8em;
            line-height: 1.3;
            margin: 10px 0;
        }
        .example-box {
            border: 2px solid #007acc;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            background-color: #f8f9fa;
        }
        .output-box {
            background-color: #000;
            color: #00ff00;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-family: monospace;
            font-size: 0.7em;
        }
        .concept-box {
            background-color: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 10px;
            margin: 10px 0;
        }
        .warning-box {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 10px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="reveal">
        <div class="slides">
            <!-- Title Slide -->
            <section>
                <h1>Java Advanced Topics</h1>
                <h3>Wrapper Classes, Command Line Arguments & Extended Concepts</h3>
                <p style="text-align: center; margin-top: 50px;">
                    <strong>Chapter 14: Supplementary Java Topics</strong><br>
                    Completing the comprehensive Java programming curriculum
                </p>
            </section>

            <!-- Wrapper Classes Overview -->
            <section>
                <h2>Wrapper Classes in Java</h2>
                <div class="concept-box">
                    <h3>What are Wrapper Classes?</h3>
                    <p>Wrapper classes provide a way to use primitive data types as objects. They "wrap" primitive values in an object so they can be used where objects are required.</p>
                </div>
                
                <div class="two-column">
                    <div class="column">
                        <h3>Primitive to Wrapper Mapping</h3>
                        <table style="width: 100%; font-size: 0.8em; border-collapse: collapse;">
                            <tr style="background-color: #f0f0f0;">
                                <th style="padding: 8px; border: 1px solid #ddd;">Primitive Type</th>
                                <th style="padding: 8px; border: 1px solid #ddd;">Wrapper Class</th>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border: 1px solid #ddd;">byte</td>
                                <td style="padding: 8px; border: 1px solid #ddd;">Byte</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border: 1px solid #ddd;">short</td>
                                <td style="padding: 8px; border: 1px solid #ddd;">Short</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border: 1px solid #ddd;">int</td>
                                <td style="padding: 8px; border: 1px solid #ddd;">Integer</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border: 1px solid #ddd;">long</td>
                                <td style="padding: 8px; border: 1px solid #ddd;">Long</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border: 1px solid #ddd;">float</td>
                                <td style="padding: 8px; border: 1px solid #ddd;">Float</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border: 1px solid #ddd;">double</td>
                                <td style="padding: 8px; border: 1px solid #ddd;">Double</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border: 1px solid #ddd;">char</td>
                                <td style="padding: 8px; border: 1px solid #ddd;">Character</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border: 1px solid #ddd;">boolean</td>
                                <td style="padding: 8px; border: 1px solid #ddd;">Boolean</td>
                            </tr>
                        </table>
                    </div>
                    <div class="column">
                        <h3>Why Use Wrapper Classes?</h3>
                        <ul>
                            <li><strong>Collections:</strong> Can store only objects, not primitives</li>
                            <li><strong>Generics:</strong> Work only with objects</li>
                            <li><strong>Utility Methods:</strong> Conversion, parsing, comparison methods</li>
                            <li><strong>Null Values:</strong> Can represent null, primitives cannot</li>
                            <li><strong>Synchronization:</strong> Can be used in synchronized collections</li>
                        </ul>
                        
                        <h3>Basic Example</h3>
                        <pre><code class="java">
// Creating wrapper objects
Integer num1 = new Integer(10);  // Deprecated
Integer num2 = Integer.valueOf(20);  // Preferred
Integer num3 = 30;  // Autoboxing

// Converting back to primitive
int primitive = num1.intValue();  // Unboxing
int auto = num2;  // Auto-unboxing
                        </code></pre>
                    </div>
                </div>
            </section>

            <!-- Autoboxing and Unboxing -->
            <section>
                <h2>Autoboxing and Unboxing</h2>
                <div style="text-align: center; margin: 20px 0;">
                    <img src="diagrams/wrapper-classes-autoboxing.svg" alt="Wrapper Classes Autoboxing Process" style="max-width: 100%; height: auto;">
                </div>
                <div class="two-column">
                    <div class="column">
                        <div class="concept-box">
                            <h3>Autoboxing</h3>
                            <p>Automatic conversion of primitive types to their corresponding wrapper class objects.</p>
                        </div>
                        <pre><code class="java">
// Autoboxing examples
Integer num = 100;  // int to Integer
Double d = 3.14;    // double to Double
Boolean b = true;   // boolean to Boolean
Character c = 'A';  // char to Character

// In collections
List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();
numbers.add(10);    // Autoboxing: int to Integer
numbers.add(20);
numbers.add(30);

// In method calls
public void processNumber(Integer num) {
    System.out.println("Number: " + num);
}

processNumber(42);  // Autoboxing: int to Integer
                        </code></pre>
                    </div>
                    <div class="column">
                        <div class="concept-box">
                            <h3>Unboxing</h3>
                            <p>Automatic conversion of wrapper class objects to their corresponding primitive types.</p>
                        </div>
                        <pre><code class="java">
// Unboxing examples
Integer num = new Integer(100);
int primitive = num;  // Integer to int

// In arithmetic operations
Integer a = 10;
Integer b = 20;
int sum = a + b;  // Both unboxed, then sum calculated

// In conditional statements
Boolean flag = Boolean.valueOf(true);
if (flag) {  // Boolean unboxed to boolean
    System.out.println("Flag is true");
}

// In array operations
Integer[] wrapperArray = {1, 2, 3, 4, 5};
int total = 0;
for (int value : wrapperArray) {  // Unboxing
    total += value;
}
                        </code></pre>
                    </div>
                </div>
                
                <div class="warning-box">
                    <h3>‚ö†Ô∏è Performance Consideration</h3>
                    <p>Autoboxing/unboxing can impact performance in loops. Use primitives when possible for intensive operations.</p>
                </div>
            </section>

            <!-- Wrapper Class Methods -->
            <section>
                <h2>Wrapper Class Utility Methods</h2>
                <div class="two-column">
                    <div class="column">
                        <h3>Integer Class Methods</h3>
                        <pre><code class="java">
// Parsing strings to numbers
int num1 = Integer.parseInt("123");
int num2 = Integer.parseInt("1010", 2);  // Binary
int num3 = Integer.parseInt("FF", 16);   // Hexadecimal

// Creating Integer objects
Integer obj1 = Integer.valueOf(100);
Integer obj2 = Integer.valueOf("200");

// Conversion methods
String binary = Integer.toBinaryString(10);  // "1010"
String hex = Integer.toHexString(255);       // "ff"
String octal = Integer.toOctalString(8);     // "10"

// Comparison
Integer a = 100, b = 200;
int result = a.compareTo(b);  // -1 (a < b)

// Min/Max values
int maxInt = Integer.MAX_VALUE;  // 2147483647
int minInt = Integer.MIN_VALUE;  // -2147483648

// Utility methods
Integer.max(10, 20);  // Returns 20
Integer.min(10, 20);  // Returns 10
Integer.sum(10, 20);  // Returns 30
                        </code></pre>
                    </div>
                    <div class="column">
                        <h3>Character Class Methods</h3>
                        <pre><code class="java">
// Character testing methods
char ch = 'A';
Character.isLetter(ch);      // true
Character.isDigit('5');      // true
Character.isWhitespace(' '); // true
Character.isUpperCase('A');  // true
Character.isLowerCase('a');  // true

// Character conversion
Character.toUpperCase('a');  // 'A'
Character.toLowerCase('Z');  // 'z'
Character.toString('X');     // "X"

// Numeric value
Character.getNumericValue('5');  // 5
Character.getNumericValue('A');  // 10 (hex)

// Creating Character objects
Character charObj = Character.valueOf('B');
                        </code></pre>
                        
                        <h3>Boolean Class Methods</h3>
                        <pre><code class="java">
// Parsing strings to boolean
Boolean.parseBoolean("true");   // true
Boolean.parseBoolean("false");  // false
Boolean.parseBoolean("TRUE");   // true (case insensitive)

// Creating Boolean objects
Boolean b1 = Boolean.valueOf(true);
Boolean b2 = Boolean.valueOf("false");

// Logical operations
Boolean.logicalAnd(true, false);  // false
Boolean.logicalOr(true, false);   // true
Boolean.logicalXor(true, false);  // true

// Comparison
Boolean a = true, b = false;
a.compareTo(b);  // 1 (true > false)
                        </code></pre>
                    </div>
                </div>
            </section>

            <!-- Command Line Arguments -->
            <section>
                <h2>Command Line Arguments</h2>
                <div class="concept-box">
                    <h3>What are Command Line Arguments?</h3>
                    <p>Command line arguments are parameters passed to a Java program when it is executed from the command line. They are stored in the String array parameter of the main method.</p>
                </div>
                
                <div class="two-column">
                    <div class="column">
                        <h3>Basic Example</h3>
                        <pre><code class="java">
// CommandLineExample.java
public class CommandLineExample {
    public static void main(String[] args) {
        System.out.println("Number of arguments: " + args.length);
        
        // Display all arguments
        for (int i = 0; i < args.length; i++) {
            System.out.println("Argument " + i + ": " + args[i]);
        }
        
        // Enhanced for loop
        System.out.println("\nAll arguments:");
        for (String arg : args) {
            System.out.println(arg);
        }
    }
}
                        </code></pre>
                        
                        <h3>Running the Program</h3>
                        <div class="output-box">
java CommandLineExample Hello World 123
                        </div>
                        
                        <h3>Output</h3>
                        <div class="output-box">
Number of arguments: 3
Argument 0: Hello
Argument 1: World
Argument 2: 123

All arguments:
Hello
World
123
                        </div>
                    </div>
                    <div class="column">
                        <h3>Practical Calculator Example</h3>
                        <pre><code class="java">
// Calculator.java
public class Calculator {
    public static void main(String[] args) {
        if (args.length != 3) {
            System.out.println("Usage: java Calculator <num1> <operator> <num2>");
            System.out.println("Example: java Calculator 10 + 5");
            return;
        }
        
        try {
            double num1 = Double.parseDouble(args[0]);
            String operator = args[1];
            double num2 = Double.parseDouble(args[2]);
            double result = 0;
            
            switch (operator) {
                case "+":
                    result = num1 + num2;
                    break;
                case "-":
                    result = num1 - num2;
                    break;
                case "*":
                case "x":
                    result = num1 * num2;
                    break;
                case "/":
                    if (num2 == 0) {
                        System.out.println("Error: Division by zero!");
                        return;
                    }
                    result = num1 / num2;
                    break;
                default:
                    System.out.println("Error: Invalid operator " + operator);
                    return;
            }
            
            System.out.println(num1 + " " + operator + " " + num2 + " = " + result);
            
        } catch (NumberFormatException e) {
            System.out.println("Error: Invalid number format!");
        }
    }
}
                        </code></pre>
                    </div>
                </div>
            </section>

            <!-- Advanced Command Line Processing -->
            <section>
                <h2>Advanced Command Line Processing</h2>
                <div class="two-column">
                    <div class="column">
                        <h3>File Processing Example</h3>
                        <pre><code class="java">
// FileProcessor.java
import java.io.*;
import java.util.Scanner;

public class FileProcessor {
    public static void main(String[] args) {
        if (args.length == 0) {
            System.out.println("Usage: java FileProcessor <filename> [options]");
            System.out.println("Options:");
            System.out.println("  -c  Count lines");
            System.out.println("  -w  Count words");
            System.out.println("  -s  Show file size");
            return;
        }
        
        String filename = args[0];
        boolean countLines = false;
        boolean countWords = false;
        boolean showSize = false;
        
        // Process options
        for (int i = 1; i < args.length; i++) {
            switch (args[i]) {
                case "-c":
                    countLines = true;
                    break;
                case "-w":
                    countWords = true;
                    break;
                case "-s":
                    showSize = true;
                    break;
                default:
                    System.out.println("Unknown option: " + args[i]);
            }
        }
        
        processFile(filename, countLines, countWords, showSize);
    }
    
    private static void processFile(String filename, boolean countLines, 
                                  boolean countWords, boolean showSize) {
        try {
            File file = new File(filename);
            
            if (!file.exists()) {
                System.out.println("File not found: " + filename);
                return;
            }
            
            if (showSize) {
                System.out.println("File size: " + file.length() + " bytes");
            }
            
            if (countLines || countWords) {
                Scanner scanner = new Scanner(file);
                int lineCount = 0;
                int wordCount = 0;
                
                while (scanner.hasNextLine()) {
                    String line = scanner.nextLine();
                    lineCount++;
                    if (countWords) {
                        String[] words = line.trim().split("\\s+");
                        if (!line.trim().isEmpty()) {
                            wordCount += words.length;
                        }
                    }
                }
                scanner.close();
                
                if (countLines) {
                    System.out.println("Lines: " + lineCount);
                }
                if (countWords) {
                    System.out.println("Words: " + wordCount);
                }
            }
            
        } catch (FileNotFoundException e) {
            System.out.println("Error reading file: " + e.getMessage());
        }
    }
}
                        </code></pre>
                    </div>
                    <div class="column">
                        <h3>Configuration-Based Application</h3>
                        <pre><code class="java">
// ConfigApp.java
public class ConfigApp {
    private static String host = "localhost";
    private static int port = 8080;
    private static boolean debug = false;
    private static String logLevel = "INFO";
    
    public static void main(String[] args) {
        parseArguments(args);
        
        System.out.println("Application Configuration:");
        System.out.println("Host: " + host);
        System.out.println("Port: " + port);
        System.out.println("Debug: " + debug);
        System.out.println("Log Level: " + logLevel);
        
        // Start application with configuration
        startApplication();
    }
    
    private static void parseArguments(String[] args) {
        for (int i = 0; i < args.length; i++) {
            switch (args[i]) {
                case "--host":
                case "-h":
                    if (i + 1 < args.length) {
                        host = args[++i];
                    }
                    break;
                case "--port":
                case "-p":
                    if (i + 1 < args.length) {
                        try {
                            port = Integer.parseInt(args[++i]);
                        } catch (NumberFormatException e) {
                            System.err.println("Invalid port number: " + args[i]);
                        }
                    }
                    break;
                case "--debug":
                case "-d":
                    debug = true;
                    break;
                case "--log-level":
                case "-l":
                    if (i + 1 < args.length) {
                        logLevel = args[++i].toUpperCase();
                    }
                    break;
                case "--help":
                    showHelp();
                    System.exit(0);
                    break;
                default:
                    System.err.println("Unknown argument: " + args[i]);
            }
        }
    }
    
    private static void showHelp() {
        System.out.println("Usage: java ConfigApp [options]");
        System.out.println("Options:");
        System.out.println("  -h, --host <host>        Set host (default: localhost)");
        System.out.println("  -p, --port <port>        Set port (default: 8080)");
        System.out.println("  -d, --debug              Enable debug mode");
        System.out.println("  -l, --log-level <level>  Set log level (default: INFO)");
        System.out.println("  --help                   Show this help");
    }
    
    private static void startApplication() {
        System.out.println("Starting application...");
        // Application logic here
    }
}
                        </code></pre>
                    </div>
                </div>
            </section>

            <!-- Inner Classes Deep Dive -->
            <section>
                <h2>Inner Classes - Detailed Coverage</h2>
                <div style="text-align: center; margin: 20px 0;">
                    <img src="diagrams/inner-classes-hierarchy.svg" alt="Inner Classes Hierarchy and Types" style="max-width: 100%; height: auto;">
                </div>
                <div class="two-column">
                    <div class="column">
                        <h3>Regular Inner Classes</h3>
                        <pre><code class="java">
// OuterClass.java
public class OuterClass {
    private String outerField = "Outer Field";
    
    // Regular inner class
    public class InnerClass {
        private String innerField = "Inner Field";
        
        public void display() {
            System.out.println("Outer field: " + outerField);
            System.out.println("Inner field: " + innerField);
            
            // Can access outer class methods
            outerMethod();
        }
    }
    
    private void outerMethod() {
        System.out.println("Outer method called");
    }
    
    public void createInner() {
        InnerClass inner = new InnerClass();
        inner.display();
    }
    
    public static void main(String[] args) {
        OuterClass outer = new OuterClass();
        outer.createInner();
        
        // Creating inner class from outside
        OuterClass.InnerClass inner = outer.new InnerClass();
        inner.display();
    }
}
                        </code></pre>
                        
                        <h3>Method Local Inner Classes</h3>
                        <pre><code class="java">
public class MethodLocalExample {
    private String outerField = "Outer";
    
    public void methodWithInnerClass() {
        final String localVar = "Local Variable";
        
        // Method local inner class
        class LocalInnerClass {
            public void display() {
                System.out.println("Outer field: " + outerField);
                System.out.println("Local variable: " + localVar);
            }
        }
        
        LocalInnerClass local = new LocalInnerClass();
        local.display();
    }
    
    public static void main(String[] args) {
        MethodLocalExample example = new MethodLocalExample();
        example.methodWithInnerClass();
    }
}
                        </code></pre>
                    </div>
                    <div class="column">
                        <h3>Static Nested Classes</h3>
                        <pre><code class="java">
public class OuterClass {
    private static String staticField = "Static Field";
    private String instanceField = "Instance Field";
    
    // Static nested class
    public static class StaticNestedClass {
        public void display() {
            // Can access static members of outer class
            System.out.println("Static field: " + staticField);
            
            // Cannot directly access instance members
            // System.out.println(instanceField); // Compilation error
            
            // Need outer class instance to access instance members
            OuterClass outer = new OuterClass();
            System.out.println("Instance field: " + outer.instanceField);
        }
    }
    
    public static void main(String[] args) {
        // Creating static nested class instance
        OuterClass.StaticNestedClass nested = new OuterClass.StaticNestedClass();
        nested.display();
    }
}
                        </code></pre>
                        
                        <h3>Anonymous Inner Classes</h3>
                        <pre><code class="java">
interface Greeting {
    void sayHello();
}

public class AnonymousExample {
    public static void main(String[] args) {
        // Anonymous inner class implementing interface
        Greeting greeting = new Greeting() {
            @Override
            public void sayHello() {
                System.out.println("Hello from anonymous class!");
            }
        };
        
        greeting.sayHello();
        
        // Anonymous inner class extending class
        Thread thread = new Thread() {
            @Override
            public void run() {
                System.out.println("Running in anonymous thread class");
            }
        };
        
        thread.start();
        
        // Using lambda (Java 8+) - modern alternative
        Greeting lambdaGreeting = () -> System.out.println("Hello from lambda!");
        lambdaGreeting.sayHello();
    }
}
                        </code></pre>
                    </div>
                </div>
            </section>

            <!-- Garbage Collection Deep Dive -->
            <section>
                <h2>Garbage Collection in Detail</h2>
                <div style="text-align: center; margin: 20px 0;">
                    <img src="diagrams/garbage-collection-process.svg" alt="Garbage Collection Process and Memory Management" style="max-width: 100%; height: auto;">
                </div>
                <div class="two-column">
                    <div class="column">
                        <h3>How Garbage Collection Works</h3>
                        <div class="concept-box">
                            <p><strong>Garbage Collection (GC)</strong> is Java's automatic memory management feature that reclaims memory used by objects that are no longer reachable.</p>
                        </div>
                        
                        <h3>Memory Areas</h3>
                        <ul>
                            <li><strong>Young Generation:</strong> Where new objects are allocated</li>
                            <li><strong>Old Generation:</strong> Long-lived objects</li>
                            <li><strong>Permanent Generation:</strong> Class metadata (Java 7 and earlier)</li>
                            <li><strong>Metaspace:</strong> Class metadata (Java 8+)</li>
                        </ul>
                        
                        <h3>GC Process</h3>
                        <ol>
                            <li><strong>Mark:</strong> Identify which objects are still in use</li>
                            <li><strong>Sweep:</strong> Remove unmarked (unreachable) objects</li>
                            <li><strong>Compact:</strong> Defragment memory</li>
                        </ol>
                        
                        <pre><code class="java">
// Objects eligible for garbage collection
public class GCExample {
    public static void main(String[] args) {
        // Creating objects
        String str1 = new String("Hello");
        String str2 = new String("World");
        
        // str1 becomes eligible for GC
        str1 = null;
        
        // Both str1 and str2 become eligible for GC
        str1 = str2 = null;
        
        // Suggesting GC (not guaranteed)
        System.gc();
        
        // Creating objects in loop
        for (int i = 0; i < 1000; i++) {
            String temp = new String("Temporary " + i);
            // temp becomes eligible for GC at end of each iteration
        }
    }
}
                        </code></pre>
                    </div>
                    <div class="column">
                        <h3>Making Objects Eligible for GC</h3>
                        <pre><code class="java">
public class GCEligibility {
    
    // Method 1: Nullifying references
    public void nullifyReference() {
        String str = new String("Test");
        str = null; // Now eligible for GC
    }
    
    // Method 2: Reassigning references
    public void reassignReference() {
        String str1 = new String("First");
        String str2 = new String("Second");
        str1 = str2; // "First" object eligible for GC
    }
    
    // Method 3: Objects created in method scope
    public void methodScope() {
        String localStr = new String("Local");
        // localStr eligible for GC when method ends
    }
    
    // Method 4: Island of isolation
    class Node {
        Node next;
        String data;
        
        Node(String data) {
            this.data = data;
        }
    }
    
    public void islandOfIsolation() {
        Node node1 = new Node("Node1");
        Node node2 = new Node("Node2");
        
        node1.next = node2;
        node2.next = node1; // Circular reference
        
        node1 = null;
        node2 = null;
        // Both nodes eligible for GC despite circular reference
    }
}
                        </code></pre>
                        
                        <h3>finalize() Method</h3>
                        <pre><code class="java">
public class FinalizeExample {
    private String name;
    
    public FinalizeExample(String name) {
        this.name = name;
    }
    
    // Called by GC before object destruction
    @Override
    protected void finalize() throws Throwable {
        System.out.println("Finalizing: " + name);
        // Cleanup operations can be performed here
        // But avoid relying on finalize() for critical cleanup
        super.finalize();
    }
    
    public static void main(String[] args) {
        FinalizeExample obj1 = new FinalizeExample("Object1");
        FinalizeExample obj2 = new FinalizeExample("Object2");
        
        obj1 = null;
        obj2 = null;
        
        System.gc(); // Request garbage collection
        
        try {
            Thread.sleep(1000); // Give GC time to run
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
                        </code></pre>
                    </div>
                </div>
                
                <div class="warning-box">
                    <h3>‚ö†Ô∏è Important Notes about finalize()</h3>
                    <ul>
                        <li>finalize() method is deprecated in Java 9+</li>
                        <li>Not guaranteed to be called</li>
                        <li>Can cause performance issues</li>
                        <li>Use try-with-resources or explicit cleanup methods instead</li>
                    </ul>
                </div>
            </section>

            <!-- Summary Slide -->
            <section>
                <h2>Summary: Advanced Java Topics</h2>
                <div class="two-column">
                    <div class="column">
                        <h3>Wrapper Classes</h3>
                        <ul>
                            <li>Convert primitives to objects</li>
                            <li>Enable collection storage</li>
                            <li>Provide utility methods</li>
                            <li>Support autoboxing/unboxing</li>
                            <li>Essential for generics</li>
                        </ul>
                        
                        <h3>Command Line Arguments</h3>
                        <ul>
                            <li>Pass parameters to programs</li>
                            <li>Configure application behavior</li>
                            <li>Process user input</li>
                            <li>Support scripting and automation</li>
                            <li>Enable flexible program execution</li>
                        </ul>
                    </div>
                    <div class="column">
                        <h3>Inner Classes</h3>
                        <ul>
                            <li>Regular inner classes (instance-based)</li>
                            <li>Static nested classes (class-based)</li>
                            <li>Method local inner classes</li>
                            <li>Anonymous inner classes</li>
                            <li>Encapsulation and organization benefits</li>
                        </ul>
                        
                        <h3>Garbage Collection</h3>
                        <ul>
                            <li>Automatic memory management</li>
                            <li>Mark-sweep-compact algorithm</li>
                            <li>Generational garbage collection</li>
                            <li>Object lifecycle management</li>
                            <li>Performance optimization</li>
                        </ul>
                    </div>
                </div>
                
                <div class="concept-box">
                    <h3>üéØ Learning Outcomes</h3>
                    <p>You now understand the complete Java programming ecosystem including advanced memory management, flexible program configuration, and sophisticated class organization techniques that are essential for professional Java development.</p>
                </div>
            </section>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/plugin/highlight/highlight.min.js"></script>
    <script>
        Reveal.initialize({
            hash: true,
            controls: true,
            progress: true,
            center: true,
            transition: 'slide',
            plugins: [ RevealHighlight ]
        });
    </script>
</body>
</html>